---
layout: post
title: Bitbucket as a private Maven repository
published: true
comments: true
img: img/blog/wagongit/wagongit.png
---
As my previous blogposts already covered how to set up a private Maven repository, you might wonder "Why again a Maven blogpost?". Well that's a fair question and the answer is twofold:

1. Backup mechanism, to ensure you never ever loose releases.
2. Remote access outside of your local network (intranet).

As Git implicitly solves both challenges, you can understand why this blogpost makes sense.

I'll demonstrate how to configure Bitbucket and setup a free private remote Maven repository. Evidently, a fully integrated Gradle script will handle all the uploading complexity.

## Preface
While you could use any Git repository (like GitHub), I choose Bitbucket as it offers [free private repositories](https://bitbucket.org/product/pricing) for small teams. Furthermore it has an API which we will need for some of the wizardry later on.

All source code is available on Github and can be used after some minor BitBucket configuration.

## Bitbucket
Without any further a do, lets get to it and start configuring BitBucket.

Login to Bitbucket and create a new private repository called `maven_repository`.

<center><a href="{{ site.blogbaseurl }}img/blog/wagongit/createrepository.png"><img src="{{ site.blogbaseurl }}img/blog/wagongit/createrepository.png" alt="Create new BitBucket repository"></a></center>

Checkout the repository locally, create a `README.md` file and commit that file to your local branch. Now push that branch to BitBucket, BUT make sure to push it to a remote branch called "releases". (this is key, as the plugin we'll use later on depends on this)

<center><a href="{{ site.blogbaseurl }}img/blog/wagongit/releasebranch.png"><img src="{{ site.blogbaseurl }}img/blog/wagongit/releasebranch.png" alt="BitBucket repository with main branch releases."></a></center>

> **Troubleshooting releases branch**
> If you accidentally push your local branch to a remote called `master`, create a new branch locally called releases, push that to a remote `releases` and change your main branch in the BitBucket settings for that repository.
>
> <center><a href="{{ site.blogbaseurl }}img/blog/wagongit/configuremainbranch.png"><img src="{{ site.blogbaseurl }}img/blog/wagongit/configuremainbranch.png" alt="Change the main branch from master to releases"></a></center>
>
> You can safely remove origin/master if you want.

## Wagon-git
In order to upload Maven artifacts to a Git repository, we will use a Maven plugin called [Wagon-git](https://synergian.github.io/wagon-git/). This allows to reuse the existing `Maven` plugin for `Gradle` and have a straightforward configuration.

Simply add a new repository:

```groovy
repositories {
    maven { url "https://raw.github.com/synergian/wagon-git/releases" }
}
```

And configure Maven like you would normally do, but with our BitBucket repository url in a particular format:

```groovy
uploadArchives {
    repositories.mavenDeployer {
        ...
        repository(url: 'git:releases://git@bitbucket.org:' + COMPANY + '/' + REPOSITORY_NAME + '.git')
        ...
    }
}
```

Where `COMPANY` is the name of your BitBucket organization and `REPOSITORY_NAME` is `maven_repository`.

Now you can simply create a new release by running the following command:

```bash
./gradlew assembleRelease uploadArchives
```

And check BitBucket for the resulting artifacts.

<center><a href="{{ site.blogbaseurl }}img/blog/wagongit/releasecommits.png"><img src="{{ site.blogbaseurl }}img/blog/wagongit/releasecommits.png" alt="Release commit of a Maven upload to BitBucket."></a></center>

<center><a href="{{ site.blogbaseurl }}img/blog/wagongit/releasecommitdetails.png"><img src="{{ site.blogbaseurl }}img/blog/wagongit/releasecommitdetails.png" alt="File details of a release commit."></a></center>

## Ensure unique versions
By default Git allows you to override each and every file in every new commit you make. This is unwanted behavior for a Maven repository, because overriding existing releases makes build unpredictable. Imagine if you are used to using v1.1.3 library x, which is stable one day and full of bugs the next. Not exactly what you want, right?

Wagon-git unfortunately does not have this functionality built in, so we will have to use the BitBucket API to verify if a particular release already exists:

```groovy
task lookForArtifacts {
    doLast {
        ...
        def repositoryUrl = 'https://api.bitbucket.org/1.0/repositories/' + COMPANY + '/' + REPOSITORY_NAME + '/raw/releases/' + artifactPath
        ...
        if (urlExists(repositoryUrl)) {
            throw new RuntimeException("Artifact with version " + ARTIFACT_VERSION + " already exist - not executing uploadArchives")
        }
        return true
    }
}
```

Quite simple actually, just reverse engineer the url of what that particular release would be and the see if we get a 200 response or not.

Finally we ensure that we always run the previous task before running the Maven task:

```groovy
uploadArchives.dependsOn lookForArtifacts
```

<center><a href="{{ site.blogbaseurl }}img/blog/wagongit/checkforartifacts.png"><img src="{{ site.blogbaseurl }}img/blog/wagongit/checkforartifacts.png" alt="Check for existing artifacts before uploadArchives."></a></center>

## Consuming artifacts
All that's left now is to have a way to consume these artifacts in some other project.

Simply add your Maven repository to the list of repositories in your main `build.gradle` file:

```groovy
allprojects {
    repositories {
        jcenter()

        maven {
            credentials {
                username USERNAME
                password PASSWORD
            }
            url "https://api.bitbucket.org/1.0/repositories/jeroenmols/maven_repository/raw/releases"
        }
    }
}
```

Note that we have to provide a `username` and `password` as we are connecting to a private repository. Make sure not to put your username and password directly into the `build.gradle` file! That would be a major security risk. Instead have a look at [this blogpost](http://localhost:4000/blog/2015/08/13/artifactory2/) to learn how to securely provide a username and password.

Now simply add a dependency on your library like you are used to:

```groovy
dependencies {
    ...
    compile 'com.jeroenmols.awesomelibrary:awesomelibrary:1.0.0'
}
```

## Putting it all together
// TODO write how to apply and configure my script

## Wrap-up
Adding Travis CI and Coveralls code coverage to your project is fairly straightforward once you know what works and especially what doesn't work. Hopefully this blogpost was able to remove a lot of those frustrating barriers of entry.

A basic example project with everything in this blogpost integrated is available on [GitHub](https://github.com/JeroenMols/TravisCoverallsExample). But in case you're interested in a real life example, have a look at my Android library [LandscapeVideoCamera](https://github.com/JeroenMols/LandscapeVideoCamera), which actually has decent code coverage statistics.

<center>[![Build Status](https://travis-ci.org/JeroenMols/LandscapeVideoCamera.svg?branch=master)](https://travis-ci.org/JeroenMols/LandscapeVideoCamera) [![Coverage Status](https://coveralls.io/repos/JeroenMols/LandscapeVideoCamera/badge.svg?branch=master&service=github)](https://coveralls.io/github/JeroenMols/LandscapeVideoCamera?branch=master)</center>

As always you can reach me [@molsjeroen](https://twitter.com/molsjeroen) on twitter, or leave a comment below!
